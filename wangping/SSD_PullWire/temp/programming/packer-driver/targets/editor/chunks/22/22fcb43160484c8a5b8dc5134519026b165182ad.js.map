{"version":3,"sources":["file:///D:/Cocos/PlayAble/SSD_PullWire/assets/JavaScript/core/NodeRotator.ts"],"names":["_decorator","Component","Vec3","Quat","CCBoolean","CCInteger","CCFloat","ccclass","property","NodeRotator","type","tooltip","_currentSpeed","_isRotating","_rotationProgress","_initialRotation","start","node","getRotation","startRotation","stopRotation","resetRotation","setRotation","toggleDirection","clockwise","setReverse","reverse","update","dt","acceleration","maxRotationSpeed","accelerationTime","Math","min","direction","rotationAmount","applyRotation","rotationQuat","fromEuler","rotateAxis","x","y","z","onEnable","console","log"],"mappings":";;;;;;;;;;;;;;;;AAqBSA,MAAAA,U,OAAAA,U;AAAYC,MAAAA,S,OAAAA,S;AAAiBC,MAAAA,I,OAAAA,I;AAAMC,MAAAA,I,OAAAA,I;AAAYC,MAAAA,S,OAAAA,S;AAAWC,MAAAA,S,OAAAA,S;AAAWC,MAAAA,O,OAAAA,O;;;;;mFArB9E;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;OAIM;AAAEC,QAAAA,OAAF;AAAWC,QAAAA;AAAX,O,GAAwBR,U;;6BAGjBS,W,WADZF,OAAO,CAAC,aAAD,C,UAGHC,QAAQ,CAAC;AAAEE,QAAAA,IAAI,EAAEL,SAAR;AAAmBM,QAAAA,OAAO,EAAE;AAA5B,OAAD,C,UAGRH,QAAQ,CAAC;AAAEE,QAAAA,IAAI,EAAEJ,OAAR;AAAiBK,QAAAA,OAAO,EAAE;AAA1B,OAAD,C,UAGRH,QAAQ,CAAC;AAAEE,QAAAA,IAAI,EAAEN,SAAR;AAAmBO,QAAAA,OAAO,EAAE;AAA5B,OAAD,C,UAGRH,QAAQ,CAAC;AAAEE,QAAAA,IAAI,EAAEN,SAAR;AAAmBO,QAAAA,OAAO,EAAE;AAA5B,OAAD,C,UAGRH,QAAQ,CAAC;AAAEE,QAAAA,IAAI,EAAER,IAAR;AAAcS,QAAAA,OAAO,EAAE;AAAvB,OAAD,C,2BAfb,MACaF,WADb,SACiCR,SADjC,CAC2C;AAAA;AAAA;;AAAA;;AAGP;AAHO;;AAMT;AANS;;AAAA;;AAYb;AAZa;;AAeH;AAfG,eAiB/BW,aAjB+B,GAiBP,CAjBO;AAiBJ;AAjBI,eAkB/BC,WAlB+B,GAkBR,KAlBQ;AAAA,eAmB/BC,iBAnB+B,GAmBH,CAnBG;AAmBA;AAnBA,eAoB/BC,gBApB+B,GAoBN,IAAIZ,IAAJ,EApBM;AAAA;;AAoBM;AAE7Ca,QAAAA,KAAK,GAAG;AACJ;AACA,eAAKC,IAAL,CAAUC,WAAV,CAAsB,KAAKH,gBAA3B,EAFI,CAIL;;AACK,eAAKI,aAAL,GALA,CAML;AACF;;AAEDA,QAAAA,aAAa,GAAG;AACZ,cAAI,KAAKN,WAAT,EAAsB;AAEtB,eAAKA,WAAL,GAAmB,IAAnB;AACA,eAAKD,aAAL,GAAqB,CAArB;AACA,eAAKE,iBAAL,GAAyB,CAAzB;AACH;;AAEDM,QAAAA,YAAY,GAAG;AACX,eAAKP,WAAL,GAAmB,KAAnB;AACH;;AAEDQ,QAAAA,aAAa,GAAG;AACZ,eAAKD,YAAL;AACA,eAAKH,IAAL,CAAUK,WAAV,CAAsB,KAAKP,gBAA3B;AACA,eAAKD,iBAAL,GAAyB,CAAzB;AACH;;AAEDS,QAAAA,eAAe,GAAG;AACd,eAAKC,SAAL,GAAiB,CAAC,KAAKA,SAAvB;AACH,SAnDsC,CAqDvC;;;AACAC,QAAAA,UAAU,CAACC,OAAD,EAAmB;AACzB,eAAKA,OAAL,GAAeA,OAAf;AACH;;AAESC,QAAAA,MAAM,CAACC,EAAD,EAAa;AACzB,cAAI,CAAC,KAAKf,WAAV,EAAuB,OADE,CAGzB;;AACA,gBAAMgB,YAAY,GAAG,KAAKC,gBAAL,GAAwB,KAAKC,gBAAlD,CAJyB,CAMzB;;AACA,cAAI,KAAKnB,aAAL,GAAqB,KAAKkB,gBAA9B,EAAgD;AAC5C,iBAAKlB,aAAL,IAAsBiB,YAAY,GAAGD,EAArC,CAD4C,CAE5C;;AACA,iBAAKhB,aAAL,GAAqBoB,IAAI,CAACC,GAAL,CAAS,KAAKrB,aAAd,EAA6B,KAAKkB,gBAAlC,CAArB;AACH,WAXwB,CAazB;AACA;;;AACA,gBAAMI,SAAS,GAAI,KAAKV,SAAL,KAAmB,KAAKE,OAAzB,GAAoC,CAApC,GAAwC,CAAC,CAA3D;AACA,gBAAMS,cAAc,GAAG,KAAKvB,aAAL,GAAqBgB,EAArB,GAA0BM,SAAjD;AACA,eAAKpB,iBAAL,IAA0BqB,cAA1B,CAjByB,CAmBzB;;AACA,eAAKC,aAAL;AACH;;AAEOA,QAAAA,aAAa,GAAG;AACpB;AACA,gBAAMC,YAAY,GAAG,IAAIlC,IAAJ,EAArB;AACAA,UAAAA,IAAI,CAACmC,SAAL,CAAeD,YAAf,EACI,KAAKE,UAAL,CAAgBC,CAAhB,GAAoB,KAAK1B,iBAD7B,EAEI,KAAKyB,UAAL,CAAgBE,CAAhB,GAAoB,KAAK3B,iBAF7B,EAGI,KAAKyB,UAAL,CAAgBG,CAAhB,GAAoB,KAAK5B,iBAH7B,EAHoB,CASpB;;AACA,eAAKG,IAAL,CAAUK,WAAV,CAAsBe,YAAtB;AACH,SA5FsC,CA8FvC;;;AACAM,QAAAA,QAAQ,GAAG;AACPC,UAAAA,OAAO,CAACC,GAAR,CAAa;AACrB,gBAAgB,KAAKf,gBAAiB;AACtC,gBAAgB,KAAKC,gBAAiB;AACtC,gBAAgB,KAAKP,SAAL,GAAiB,KAAjB,GAAyB,KAAM;AAC/C,gBAAgB,KAAKE,OAAL,GAAe,GAAf,GAAqB,GAAI;AACzC,SALQ;AAMH;;AAtGsC,O;;;;;iBAGZ,G;;;;;;;iBAGA,C;;;;;;;iBAGN,I;;;;;;;iBAGF,K;;;;;;;iBAGA,IAAIxB,IAAJ,CAAS,CAAT,EAAW,CAAX,EAAa,CAAb,C","sourcesContent":["// import { _decorator, Component, Node, tween, Vec3, Quat, math, Tween, TweenEasing } from 'cc';\r\n// const { ccclass, property } = _decorator;\r\n\r\n// @ccclass('NodeRotator')\r\n// export class NodeRotator extends Component {\r\n//     start() {\r\n//         this.scheduleOnce(() => {\r\n//             this.rotator();\r\n//         }, 2);\r\n//     }\r\n//     rotator() {\r\n\r\n//         // 持续旋转（绕Y轴每秒旋转360度）\r\n//         tween(this.node)\r\n//             .by(2, { eulerAngles: new Vec3(0, 360, 0) }) // 相对旋转\r\n//             .repeatForever() // 永久重复\r\n//             .start();\r\n//     }\r\n// }\r\n\r\n\r\nimport { _decorator, Component, Node, Vec3, Quat, math, CCBoolean, CCInteger, CCFloat } from 'cc';\r\nconst { ccclass, property } = _decorator;\r\n\r\n@ccclass('NodeRotator')\r\nexport class NodeRotator extends Component {\r\n\r\n    @property({ type: CCInteger, tooltip: '最大旋转速度 (度/秒)' })\r\n    maxRotationSpeed: number = 360; // 每秒360度（1圈/秒）\r\n\r\n    @property({ type: CCFloat, tooltip: '加速时间 (秒)' })\r\n    accelerationTime: number = 2; // 从0加速到最大速度所需时间\r\n\r\n    @property({ type: CCBoolean, tooltip: '顺时针旋转' })\r\n    clockwise: boolean = true;\r\n\r\n    @property({ type: CCBoolean, tooltip: '逆向旋转' })\r\n    reverse: boolean = false; // 新增属性，用于控制是否逆向旋转\r\n\r\n    @property({ type: Vec3, tooltip: '旋转轴' })\r\n    rotateAxis: Vec3 = new Vec3(0,1,0); // 默认绕Y轴旋转\r\n\r\n    private _currentSpeed: number = 0; // 当前旋转速度 (度/秒)\r\n    private _isRotating: boolean = false;\r\n    private _rotationProgress: number = 0; // 当前旋转角度（度）\r\n    private _initialRotation: Quat = new Quat(); // 初始旋转状态\r\n\r\n    start() {\r\n        // 保存初始旋转状态\r\n        this.node.getRotation(this._initialRotation);\r\n\r\n       // this.scheduleOnce(() => {\r\n            this.startRotation();\r\n       // }, 5); // 延迟1秒开始旋转，便于观察\r\n    }\r\n\r\n    startRotation() {\r\n        if (this._isRotating) return;\r\n\r\n        this._isRotating = true;\r\n        this._currentSpeed = 0;\r\n        this._rotationProgress = 0;\r\n    }\r\n\r\n    stopRotation() {\r\n        this._isRotating = false;\r\n    }\r\n\r\n    resetRotation() {\r\n        this.stopRotation();\r\n        this.node.setRotation(this._initialRotation);\r\n        this._rotationProgress = 0;\r\n    }\r\n\r\n    toggleDirection() {\r\n        this.clockwise = !this.clockwise;\r\n    }\r\n\r\n    // 新增方法：设置逆向旋转状态\r\n    setReverse(reverse: boolean) {\r\n        this.reverse = reverse;\r\n    }\r\n\r\n    protected update(dt: number) {\r\n        if (!this._isRotating) return;\r\n\r\n        // 1. 计算加速度 (度/秒²)\r\n        const acceleration = this.maxRotationSpeed / this.accelerationTime;\r\n\r\n        // 2. 更新当前速度（线性加速）\r\n        if (this._currentSpeed < this.maxRotationSpeed) {\r\n            this._currentSpeed += acceleration * dt;\r\n            // 确保不超过最大速度\r\n            this._currentSpeed = Math.min(this._currentSpeed, this.maxRotationSpeed);\r\n        }\r\n\r\n        // 3. 计算本帧旋转角度\r\n        // 修改旋转方向计算，同时考虑clockwise和reverse参数\r\n        const direction = (this.clockwise !== this.reverse) ? 1 : -1;\r\n        const rotationAmount = this._currentSpeed * dt * direction;\r\n        this._rotationProgress += rotationAmount;\r\n\r\n        // 4. 应用旋转\r\n        this.applyRotation();\r\n    }\r\n\r\n    private applyRotation() {\r\n        // 创建旋转四元数\r\n        const rotationQuat = new Quat();\r\n        Quat.fromEuler(rotationQuat, \r\n            this.rotateAxis.x * this._rotationProgress,\r\n            this.rotateAxis.y * this._rotationProgress,\r\n            this.rotateAxis.z * this._rotationProgress\r\n        );\r\n\r\n        // 应用旋转\r\n        this.node.setRotation(rotationQuat);\r\n    }\r\n\r\n    // 调试信息 - 更新以显示reverse状态\r\n    onEnable() {\r\n        console.log(`旋转控制器已启用:\r\n        最大速度: ${this.maxRotationSpeed} 度/秒\r\n        加速时间: ${this.accelerationTime} 秒\r\n        旋转方向: ${this.clockwise ? '顺时针' : '逆时针'}\r\n        逆向状态: ${this.reverse ? '是' : '否'}\r\n        `);\r\n    }\r\n}"]}