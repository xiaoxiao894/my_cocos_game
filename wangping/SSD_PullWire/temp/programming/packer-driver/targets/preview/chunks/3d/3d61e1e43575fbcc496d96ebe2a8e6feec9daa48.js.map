{"version":3,"sources":["file:///D:/Cocos/PlayAble/SSD_PullWire/assets/JavaScript/Utils/MathUtils.ts"],"names":["MathUtil","Vec3","v3","Quat","Mat4","tempVec","tempVec2","tempVec3","up","generateSmoothPath","startPos","endPos","segmentCount","curveHeight","pathPoints","midPoint","lerp","y","positions","i","t","push","quadraticBezier","length","tangent","clone","subtract","prevDir","nextDir","add","multiplyScalar","normalize","rotation","equals","ZERO","rotationTo","position","p0","p1","p2","u","uu","tt","x","z","getAngleBetweenQuats","currentRot","targetRot","dot","clampedDot","Math","min","max","acos","localToWorldPos3D","localPos","targetNode","isValid","console","warn","worldPos","transformMat4","worldMatrix","worldToLocal","worldMatInv","invert"],"mappings":"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","sourcesContent":["import { _decorator, Vec3, v3, Quat, Mat4, Node } from 'cc';\r\n\r\nlet tempVec: Vec3 = v3()\r\nlet tempVec2: Vec3 = v3()\r\nlet tempVec3: Vec3 = v3()\r\nlet up = v3()\r\n\r\nexport class MathUtil {\r\n\r\n    /**\r\n     * 生成平滑3D路径\r\n     * @param startPos 起点位置\r\n     * @param endPos 终点位置\r\n     * @param segmentCount 生成的段数\r\n     * @param curveHeight 曲线高度(控制路径弯曲程度)\r\n     * @returns 包含位置和旋转的路径点数组\r\n     */\r\n    public static generateSmoothPath(\r\n        startPos: Vec3,\r\n        endPos: Vec3,\r\n        segmentCount: number = 100,\r\n        curveHeight: number = 5\r\n    ): { position: Vec3, rotation: Quat }[] {\r\n        // 计算结果数组\r\n        const pathPoints: { position: Vec3, rotation: Quat }[] = [];\r\n\r\n        // 计算中间控制点(形成曲线顶部)\r\n        const midPoint = Vec3.lerp(new Vec3(), startPos, endPos, 0.5);\r\n        midPoint.y += curveHeight;\r\n\r\n        // 计算所有点的位置(二次贝塞尔曲线)\r\n        const positions: Vec3[] = [];\r\n        for (let i = 0; i <= segmentCount; i++) {\r\n            const t = i / segmentCount;\r\n            positions.push(this.quadraticBezier(startPos, midPoint, endPos, t));\r\n        }\r\n\r\n        // 计算每个点的旋转角度(基于切线方向)\r\n        for (let i = 0; i < positions.length; i++) {\r\n            let tangent: Vec3;\r\n\r\n            if (i === 0) {\r\n                // 第一个点：使用下一个点的方向\r\n                tangent = positions[i + 1].clone();\r\n                tangent = tangent.subtract(positions[i]);\r\n            } else if (i === positions.length - 1) {\r\n                // 最后一个点：使用前一个点的方向\r\n                tangent = positions[i].clone();\r\n                tangent = tangent.subtract(positions[i - 1]);\r\n            } else {\r\n                // 中间点：使用前后点的平均方向\r\n                const prevDir = positions[i].clone();\r\n                prevDir.subtract(positions[i - 1]);\r\n                const nextDir = positions[i + 1].clone();\r\n                nextDir.subtract(positions[i]);\r\n                tangent = prevDir.add(nextDir).multiplyScalar(0.5);\r\n            }\r\n\r\n            tangent.normalize();\r\n\r\n            // 计算旋转(使物体朝向切线方向)\r\n            const rotation = new Quat();\r\n            if (!tangent.equals(Vec3.ZERO)) {\r\n                const up = new Vec3(0, 1, 0);\r\n                Quat.rotationTo(rotation, up, tangent);\r\n            }\r\n\r\n            pathPoints.push({\r\n                position: positions[i],\r\n                rotation\r\n            });\r\n        }\r\n\r\n        return pathPoints;\r\n    }\r\n\r\n    // 二次贝塞尔曲线辅助函数\r\n    public static quadraticBezier(p0: Vec3, p1: Vec3, p2: Vec3, t: number): Vec3 {\r\n        const u = 1 - t;\r\n        const uu = u * u;\r\n        const tt = t * t;\r\n\r\n        const x = uu * p0.x + 2 * u * t * p1.x + tt * p2.x;\r\n        const y = uu * p0.y + 2 * u * t * p1.y + tt * p2.y;\r\n        const z = uu * p0.z + 2 * u * t * p1.z + tt * p2.z;\r\n\r\n        return new Vec3(x, y, z);\r\n    }\r\n\r\n    // 计算当前旋转与目标旋转之间的角度差（弧度）\r\n    public static getAngleBetweenQuats(currentRot: Quat, targetRot: Quat): number {\r\n        // 计算两个四元数之间的点积\r\n        const dot = Quat.dot(currentRot, targetRot);\r\n\r\n        // 确保点积在有效范围内[-1, 1]\r\n        const clampedDot = Math.min(1, Math.max(-1, dot));\r\n\r\n        // 返回角度差（弧度）\r\n        return Math.acos(clampedDot) * 2;\r\n    }\r\n\r\n    /**\r\n     * 将节点局部坐标转换为世界坐标\r\n     * @param localPos 局部坐标(Vec3)\r\n     * @param targetNode 目标节点(Node)\r\n     * @returns 世界坐标(Vec3)\r\n     */\r\n    public static localToWorldPos3D(localPos: Vec3, targetNode: Node): Vec3 {\r\n        if (!targetNode.isValid) {\r\n            console.warn('Target node is invalid!');\r\n            return localPos.clone();\r\n        }\r\n\r\n        const worldPos = new Vec3();\r\n        Vec3.transformMat4(worldPos, localPos, targetNode.worldMatrix);\r\n\r\n        return worldPos;\r\n    }\r\n\r\n    public static worldToLocal(worldPos: Vec3, targetNode: Node): Vec3 {\r\n        // 获取节点的世界变换矩阵的逆矩阵\r\n        const worldMatInv = new Mat4();\r\n        Mat4.invert(worldMatInv, targetNode.worldMatrix);\r\n\r\n        // 应用逆矩阵转换坐标\r\n        const localPos = new Vec3();\r\n        Vec3.transformMat4(localPos, worldPos, worldMatInv);\r\n\r\n        return localPos;\r\n    }\r\n\r\n}"]}