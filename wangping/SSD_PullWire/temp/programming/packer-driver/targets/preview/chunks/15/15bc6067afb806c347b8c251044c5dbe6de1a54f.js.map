{"version":3,"sources":["file:///D:/Cocos/PlayAble/SSD_PullWire/assets/JavaScript/Utils/TransformPositionUtil.ts"],"names":["TransformPositionUtil","Mat4","Vec2","Vec3","DataManager","getDepthRatio","camera","worldPos","inverseMat","invert","node","worldMatrix","localPos","transformMat4","depth","z","near","far","getProjectionRatio","a","b","c","ab","subtract","ac","abLengthSq","lengthSqr","Number","EPSILON","ratio","dot","getPlugPos","pos","Instance","mainCamera","ray","screenPointToRay","x","y","lastPos","nowPlug","worldPosition","clone","closestPoint","getClosestPointOnRay","calculateHeight","applySmoothing","targetPoint","rayDirection","d","normalize","rayToPoint","o","projection","add","multiplyScalar","distance","Math","sqrt","normalizedDistance","min","pow","applyBoundaryLimits","moveBoundary","len","factor","targetPos","smoothFactor","maxMoveDistance","moveDistance","dynamicSmooth"],"mappings":"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","sourcesContent":["import { Camera, geometry, Mat4, UITransform, Vec2, Vec3 } from \"cc\";\r\nimport { DataManager } from \"../Global/DataManager\";\r\n\r\nexport default class TransformPositionUtil {\r\n    \r\n    // 获取点在远近平面之间的比例 (0=近平面, 1=远平面)\r\n    public static getDepthRatio(camera: Camera, worldPos: Vec3): number {\r\n        // 创建逆矩阵\r\n        const inverseMat = new Mat4();\r\n        Mat4.invert(inverseMat, camera.node.worldMatrix);\r\n        \r\n        // 应用矩阵变换\r\n        const localPos = new Vec3();\r\n        Vec3.transformMat4(localPos, worldPos, inverseMat);\r\n        \r\n        const depth = -localPos.z; // 视图空间中的深度值\r\n        // 计算标准化深度 (0到1之间)\r\n        return (depth - camera.near) / (camera.far - camera.near);\r\n    }\r\n\r\n    /**\r\n     * 计算点C在AB直线上的投影比例\r\n     * @param a 点A坐标\r\n     * @param b 点B坐标 \r\n     * @param c 点C坐标\r\n     * @returns 投影点到A的距离与AB长度的比例 (范围可能超出[0,1])\r\n     */\r\n    public static getProjectionRatio(a: Vec2, b: Vec2, c: Vec2): number {\r\n        // 计算向量AB和AC\r\n        const ab = b.subtract(a);\r\n        const ac = c.subtract(a);\r\n        \r\n        // 计算AB长度的平方\r\n        const abLengthSq = ab.lengthSqr();\r\n        \r\n        // 如果AB长度接近0，返回0避免除零错误\r\n        if (abLengthSq < Number.EPSILON) {\r\n            return 0;\r\n        }\r\n        \r\n        // 计算投影比例 (向量点积公式)\r\n        const ratio = Vec2.dot(ac, ab) / abLengthSq;\r\n        \r\n        return ratio;\r\n    }\r\n\r\n\r\n    /**\r\n     * 获取插件位置 (主方法)\r\n     */\r\n    public static getPlugPos(pos: Vec2): Vec3 {\r\n        const camera = DataManager.Instance.mainCamera.camera;\r\n        const ray = camera.screenPointToRay(pos.x, pos.y);\r\n        const lastPos = DataManager.Instance.nowPlug.worldPosition.clone();\r\n\r\n        // 1. 计算射线上最近的点\r\n        const closestPoint = this.getClosestPointOnRay(ray, lastPos);\r\n        \r\n        // 2. 应用高度曲线\r\n        closestPoint.y = this.calculateHeight(closestPoint.x, closestPoint.z);\r\n        \r\n        // 3. 边界限制\r\n        //this.applyBoundaryLimits(closestPoint);\r\n        \r\n        // 4. 动态平滑处理\r\n        return this.applySmoothing(lastPos, closestPoint);\r\n    }\r\n\r\n    /**\r\n     * 计算射线上距离目标点最近的点\r\n     */\r\n    public static getClosestPointOnRay(ray: geometry.Ray, targetPoint: Vec3): Vec3 {\r\n        const rayDirection = ray.d.normalize();\r\n        const rayToPoint = Vec3.subtract(new Vec3(), targetPoint, ray.o);\r\n        const projection = Vec3.dot(rayToPoint, rayDirection);\r\n\r\n        return projection <= 0 \r\n            ? ray.o.clone() \r\n            : ray.o.add(rayDirection.multiplyScalar(projection));\r\n    }\r\n\r\n    /**\r\n     * 高度计算函数 (基于与原点距离)\r\n     */\r\n    public static calculateHeight(x: number, z: number): number {\r\n        const distance = Math.sqrt(x * x + z * z);\r\n        const normalizedDistance = Math.min(distance, 10);\r\n        // 二次曲线平滑过渡：原点高度10，距离10时高度3\r\n        return 3 + 7 * Math.pow(1 - normalizedDistance / 10, 2);\r\n    }\r\n\r\n    /**\r\n     * 应用移动边界限制\r\n     */\r\n    public static applyBoundaryLimits(pos: Vec3): void {\r\n\r\n        // 移动边界限制\r\n        let moveBoundary: number = 10.0;\r\n\r\n        const len = Math.sqrt(pos.x * pos.x + pos.z * pos.z);\r\n        if (len > moveBoundary) {\r\n            const factor = moveBoundary / len;\r\n            pos.x *= factor;\r\n            pos.z *= factor;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 应用动态平滑过渡\r\n     */\r\n    public static applySmoothing(lastPos: Vec3, targetPos: Vec3): Vec3 {\r\n\r\n        // 平滑系数 (0.1-1.0，越小越平滑)\r\n        let smoothFactor: number = 0.3;\r\n        // 最大移动距离 (防止瞬间跳跃)\r\n        let maxMoveDistance: number = 5.0;\r\n\r\n        // 计算实际移动距离\r\n        const moveDistance = Vec3.distance(lastPos, targetPos);\r\n        \r\n        // 动态调整平滑系数 (移动越快越不平滑)\r\n        const dynamicSmooth = Math.min(smoothFactor, 1 / (moveDistance + 0.1));\r\n        \r\n        // 限制最大移动距离\r\n        if (moveDistance > maxMoveDistance) {\r\n            return lastPos;\r\n        }\r\n        \r\n        // 应用线性插值\r\n        return new Vec3(\r\n            lastPos.x + (targetPos.x - lastPos.x) * dynamicSmooth,\r\n            lastPos.y + (targetPos.y - lastPos.y) * dynamicSmooth,\r\n            lastPos.z + (targetPos.z - lastPos.z) * dynamicSmooth\r\n        );\r\n    }\r\n\r\n\r\n}"]}