{"version":3,"sources":["file:///D:/Cocos/PlayAble/SSD_UnlockPlot/assets/Script/MathUtils.ts"],"names":["MathUtil","Vec3","v3","Quat","tempVec","tempVec2","tempVec3","up","generateSmoothPath","startPos","endPos","segmentCount","curveHeight","pathPoints","midPoint","lerp","y","positions","i","t","push","quadraticBezier","length","tangent","clone","subtract","prevDir","nextDir","add","multiplyScalar","normalize","rotation","equals","ZERO","rotationTo","position","p0","p1","p2","u","uu","tt","x","z","getAngleBetweenQuats","currentRot","targetRot","dot","clampedDot","Math","min","max","acos","localToWorldPos3D","localPos","targetNode","isValid","console","warn","worldPos","transformMat4","worldMatrix","signAngle","from","to","axis","angle","cross","sign","eulerToForward","eulerAngles","fromEuler","forward","transformQuat","bezierCurve","start","control","end","p"],"mappings":"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","sourcesContent":["import { _decorator,  Vec3, v3, Quat, Mat4,Node } from 'cc';\r\n\r\nlet tempVec: Vec3 = v3()\r\nlet tempVec2: Vec3 = v3()\r\nlet tempVec3: Vec3 = v3()\r\nlet up = v3()\r\n\r\nexport class MathUtil {\r\n\r\n    /**\r\n     * 生成平滑3D路径\r\n     * @param startPos 起点位置\r\n     * @param endPos 终点位置\r\n     * @param segmentCount 生成的段数\r\n     * @param curveHeight 曲线高度(控制路径弯曲程度)\r\n     * @returns 包含位置和旋转的路径点数组\r\n     */\r\n    public static generateSmoothPath(\r\n        startPos: Vec3,\r\n        endPos: Vec3,\r\n        segmentCount: number = 100,\r\n        curveHeight: number = 5\r\n    ): { position: Vec3, rotation: Quat }[] {\r\n        // 计算结果数组\r\n        const pathPoints: { position: Vec3, rotation: Quat }[] = [];\r\n        \r\n        // 计算中间控制点(形成曲线顶部)\r\n        const midPoint = Vec3.lerp(new Vec3(), startPos, endPos, 0.5);\r\n        midPoint.y += curveHeight;\r\n        \r\n        // 计算所有点的位置(二次贝塞尔曲线)\r\n        const positions: Vec3[] = [];\r\n        for (let i = 0; i <= segmentCount; i++) {\r\n            const t = i / segmentCount;\r\n            positions.push(this.quadraticBezier(startPos, midPoint, endPos, t));\r\n        }\r\n        \r\n        // 计算每个点的旋转角度(基于切线方向)\r\n        for (let i = 0; i < positions.length; i++) {\r\n            let tangent: Vec3;\r\n            \r\n            if (i === 0) {\r\n                // 第一个点：使用下一个点的方向\r\n                tangent = positions[i+1].clone();\r\n                tangent = tangent.subtract(positions[i]);\r\n            } else if (i === positions.length - 1) {\r\n                // 最后一个点：使用前一个点的方向\r\n                tangent = positions[i].clone();\r\n                tangent = tangent.subtract(positions[i-1]);\r\n            } else {\r\n                // 中间点：使用前后点的平均方向\r\n                const prevDir = positions[i].clone();\r\n                prevDir.subtract(positions[i-1]);\r\n                const nextDir = positions[i+1].clone();\r\n                nextDir.subtract(positions[i]);\r\n                tangent = prevDir.add(nextDir).multiplyScalar(0.5);\r\n            }\r\n            \r\n            tangent.normalize();\r\n            \r\n            // 计算旋转(使物体朝向切线方向)\r\n            const rotation = new Quat();\r\n            if (!tangent.equals(Vec3.ZERO)) {\r\n                const up = new Vec3(0, 1, 0);\r\n                Quat.rotationTo(rotation, up, tangent);\r\n            }\r\n            \r\n            pathPoints.push({\r\n                position: positions[i],\r\n                rotation\r\n            });\r\n        }\r\n        \r\n        return pathPoints;\r\n    }\r\n\r\n    // 二次贝塞尔曲线辅助函数\r\n    public static quadraticBezier(p0: Vec3, p1: Vec3, p2: Vec3, t: number): Vec3 {\r\n        const u = 1 - t;\r\n        const uu = u * u;\r\n        const tt = t * t;\r\n        \r\n        const x = uu * p0.x + 2 * u * t * p1.x + tt * p2.x;\r\n        const y = uu * p0.y + 2 * u * t * p1.y + tt * p2.y;\r\n        const z = uu * p0.z + 2 * u * t * p1.z + tt * p2.z;\r\n        \r\n        return new Vec3(x, y, z);\r\n    }\r\n\r\n    // 计算当前旋转与目标旋转之间的角度差（弧度）\r\n    public static getAngleBetweenQuats(currentRot: Quat, targetRot: Quat): number {\r\n        // 计算两个四元数之间的点积\r\n        const dot = Quat.dot(currentRot, targetRot);\r\n        \r\n        // 确保点积在有效范围内[-1, 1]\r\n        const clampedDot = Math.min(1, Math.max(-1, dot));\r\n        \r\n        // 返回角度差（弧度）\r\n        return Math.acos(clampedDot) * 2;\r\n    }\r\n\r\n    /**\r\n     * 将节点局部坐标转换为世界坐标\r\n     * @param localPos 局部坐标(Vec3)\r\n     * @param targetNode 目标节点(Node)\r\n     * @returns 世界坐标(Vec3)\r\n     */\r\n    public static localToWorldPos3D(localPos: Vec3, targetNode: Node): Vec3 {\r\n        if (!targetNode.isValid) {\r\n            console.warn('Target node is invalid!');\r\n            return localPos.clone();\r\n        }\r\n\r\n        const worldPos = new Vec3();\r\n        Vec3.transformMat4(worldPos, localPos, targetNode.worldMatrix);\r\n        \r\n        return worldPos;\r\n    }\r\n\r\n    public static signAngle(from: Vec3, to: Vec3, axis: Vec3): number {\r\n        const angle = Vec3.angle(from, to);\r\n        Vec3.cross(tempVec, from, to);\r\n        const sign = Math.sign(axis.x * tempVec.x + axis.y * tempVec.y + axis.z * tempVec.z);\r\n        return angle * sign;\r\n    }\r\n\r\n    /**\r\n     * 将欧拉角（弧度制）转换为 forward 向量\r\n     * @param eulerAngles - 欧拉角（弧度制，顺序可能是 XYZ/YXZ，取决于引擎）\r\n     * @returns forward 向量（单位向量，指向物体的前向方向）\r\n     */\r\n    public static eulerToForward(eulerAngles: Vec3): Vec3 {\r\n        // 1. 将欧拉角转换为四元数\r\n        const rotation = new Quat();\r\n        Quat.fromEuler(rotation, eulerAngles.x, eulerAngles.y, eulerAngles.z);\r\n\r\n        // 2. 定义默认 forward 方向（Cocos Creator 默认是 -Z 轴）\r\n        const forward = new Vec3(0, 0, -1);\r\n\r\n        // 3. 应用旋转\r\n        Vec3.transformQuat(forward, forward, rotation);\r\n\r\n        // 4. 归一化（确保是单位向量）\r\n        Vec3.normalize(forward, forward);\r\n\r\n        return forward;\r\n    }\r\n\r\n    public static bezierCurve(start: Vec3, control: Vec3, end: Vec3, t: number): Vec3 {\r\n        const u = 1 - t;\r\n        const tt = t * t;\r\n        const uu = u * u;\r\n\r\n        const p = new Vec3();\r\n        p.x = uu * start.x + 2 * u * t * control.x + tt * end.x;\r\n        p.y = uu * start.y + 2 * u * t * control.y + tt * end.y;\r\n        p.z = uu * start.z + 2 * u * t * control.z + tt * end.z;\r\n\r\n        return p;\r\n    }\r\n\r\n\r\n}"]}