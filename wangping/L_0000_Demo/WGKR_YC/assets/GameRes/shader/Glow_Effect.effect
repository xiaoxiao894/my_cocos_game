CCEffect %{
  techniques:
  - passes:
    - vert: general-vs
      frag: glow-fs:frag
      rasterizerState:
        cullMode: none
      blendState: &b1
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendDstAlpha: one_minus_src_alpha
      properties: &props
        mainTexture:    { value: white }
        mainColor:      { value: [1, 1, 1, 1], editor: { type: color } }
        glowColor:      { value: [0, 0.8, 1, 1], editor: { type: color } }
        glowIntensity:  { value: 2.0 }
        glowWidth:      { value: 0.1 }
}%

CCProgram general-vs %{
  precision highp float;
  
  #include <cc-global>
  #include <cc-local>

  in vec3 a_position;
  in vec3 a_normal;
  in vec2 a_texCoord;

  out vec3 v_position;
  out vec3 v_normal;
  out vec2 v_uv;
  out vec3 v_viewDir;

  void main () {
    vec4 pos = cc_matWorld * vec4(a_position, 1.0);
    v_position = pos.xyz;
    
    // 法线转换（世界空间）
    v_normal = normalize((cc_matWorldIT * vec4(a_normal, 0.0)).xyz);
    
    v_uv = a_texCoord;
    
    // 计算视图方向（世界空间）
    v_viewDir = normalize(cc_cameraPos.xyz - v_position);
    
    gl_Position = cc_matProj * cc_matView * pos;
  }
}%

CCProgram glow-fs %{
  precision highp float;
  #include <output>
  #if USE_MAINTEXT
    uniform sampler2D mainTexture;
  #endif
  uniform glowParam{
    vec4 mainColor;
    vec4 glowColor;
    float glowIntensity;
    float glowWidth;
  };

  in vec3 v_position;
  in vec3 v_normal;
  in vec2 v_uv;
  in vec3 v_viewDir;

  vec4 frag () {
    // 基础纹理颜色
    #if USE_MAINTEXT
      vec4 baseColor = texture(mainTexture, v_uv) * mainColor;
    #else 
      vec4 baseColor = mainColor;
    #endif

    // 标准化法线和视线方向
    vec3 normal = normalize(v_normal);
    vec3 viewDir = normalize(v_viewDir);
    
    // 边缘检测：法线与视线夹角越大，值越大
    float edge = 1.0 - abs(dot(normal, viewDir));
    
    // 平滑边缘发光效果
    float glowFactor = smoothstep(0.0, glowWidth, edge);
    
    // 应用发光颜色和强度
    vec3 glow = glowColor.rgb * glowFactor * glowIntensity;
    
    // 混合基础颜色和发光效果
    vec3 finalColor = baseColor.rgb + glow;
    
    // 输出最终颜色（保持原始透明度）
    // gl_FragColor = vec4(finalColor, baseColor.a);
    return vec4(finalColor, baseColor.a);
  }
}%