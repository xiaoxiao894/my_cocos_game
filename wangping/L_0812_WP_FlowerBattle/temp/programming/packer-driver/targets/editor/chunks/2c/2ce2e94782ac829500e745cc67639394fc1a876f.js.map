{"version":3,"sources":["file:///D:/Cocos/PlayAble/L_0812_WP_FlowerBattle/assets/JavaScript/State/MoveBase.ts"],"names":["_decorator","Component","find","Quat","v3","Vec3","VirtualInput","ccclass","property","MoveBase","lastMoveDir","handleInput","dt","entity","x","horizontal","y","vertical","destForward","set","camNode","camRot","getWorldRotation","forward","right","transformQuat","normalize","moveDir","scaleAndAdd","length","lerp","moveSmoothFactor","doMove","doRotate","velocity","multiplyScalar","moveSpeed","currentPos","node","getWorldPosition","setWorldPosition","z","targetQuat","fromViewUp","UP","currentRot","slerp","rotateSpeed","setWorldRotation"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAASA,MAAAA,U,OAAAA,U;AAAYC,MAAAA,S,OAAAA,S;AAAWC,MAAAA,I,OAAAA,I;AAAYC,MAAAA,I,OAAAA,I;AAAMC,MAAAA,E,OAAAA,E;AAAIC,MAAAA,I,OAAAA,I;;AAC7CC,MAAAA,Y,iBAAAA,Y;;;;;;;;;OACH;AAAEC,QAAAA,OAAF;AAAWC,QAAAA;AAAX,O,GAAwBR,U;;0BAGjBS,Q,WADZF,OAAO,CAAC,UAAD,C,2BAAR,MACaE,QADb,SAC8BR,SAD9B,CACwC;AAAA;AAAA;;AAEpC;AAFoC;;AAIJ;AAEhC;AANoC,eAO5BS,WAP4B,GAORN,EAAE,EAPM;AAAA;;AAQpCO,QAAAA,WAAW,CAACC,EAAD,EAAaC,MAAb,EAA0B;AAEjC,gBAAMC,CAAC,GAAG;AAAA;AAAA,4CAAaC,UAAvB;AACA,gBAAMC,CAAC,GAAG;AAAA;AAAA,4CAAaC,QAAvB,CAHiC,CAKjC;;AACA,cAAIH,CAAC,KAAK,CAAN,IAAWE,CAAC,KAAK,CAArB,EAAwB;AACpBH,YAAAA,MAAM,CAACK,WAAP,CAAmBC,GAAnB,CAAuB,CAAvB,EAA0B,CAA1B,EAA6B,CAA7B;AACA;AACH;;AAED,gBAAMC,OAAO,GAAGlB,IAAI,CAAC,aAAD,CAApB;AACA,cAAI,CAACkB,OAAL,EAAc,OAZmB,CAcjC;;AACA,gBAAMC,MAAM,GAAGD,OAAO,CAACE,gBAAR,EAAf,CAfiC,CAiBjC;;AACA,gBAAMC,OAAO,GAAG,IAAIlB,IAAJ,CAAS,CAAT,EAAY,CAAZ,EAAe,CAAC,CAAhB,CAAhB;AACA,gBAAMmB,KAAK,GAAG,IAAInB,IAAJ,CAAS,CAAT,EAAY,CAAZ,EAAe,CAAf,CAAd,CAnBiC,CAqBjC;;AACAA,UAAAA,IAAI,CAACoB,aAAL,CAAmBF,OAAnB,EAA4BA,OAA5B,EAAqCF,MAArC;AACAhB,UAAAA,IAAI,CAACoB,aAAL,CAAmBD,KAAnB,EAA0BA,KAA1B,EAAiCH,MAAjC,EAvBiC,CAyBjC;;AACAE,UAAAA,OAAO,CAACP,CAAR,GAAY,CAAZ;AACAQ,UAAAA,KAAK,CAACR,CAAN,GAAU,CAAV;AACAO,UAAAA,OAAO,CAACG,SAAR;AACAF,UAAAA,KAAK,CAACE,SAAN,GA7BiC,CA+BjC;;AACA,gBAAMC,OAAO,GAAG,IAAItB,IAAJ,EAAhB;AACAA,UAAAA,IAAI,CAACuB,WAAL,CAAiBD,OAAjB,EAA0BA,OAA1B,EAAmCH,KAAnC,EAA0CV,CAA1C;AACAT,UAAAA,IAAI,CAACuB,WAAL,CAAiBD,OAAjB,EAA0BA,OAA1B,EAAmCJ,OAAnC,EAA4CP,CAA5C;AACAW,UAAAA,OAAO,CAACD,SAAR,GAnCiC,CAqCjC;;AACA,cAAIC,OAAO,CAACE,MAAR,KAAmB,GAAvB,EAA4B;AACxBF,YAAAA,OAAO,CAACD,SAAR,GADwB,CAExB;;AACArB,YAAAA,IAAI,CAACyB,IAAL,CAAU,KAAKpB,WAAf,EAA4B,KAAKA,WAAjC,EAA8CiB,OAA9C,EAAuD,KAAKI,gBAA5D;AACA,iBAAKrB,WAAL,CAAiBgB,SAAjB;AACH,WALD,MAKO;AACH,iBAAKhB,WAAL,CAAiBS,GAAjB,CAAqB,CAArB,EAAwB,CAAxB,EAA2B,CAA3B;AACH,WA7CgC,CA+CjC;;;AACAN,UAAAA,MAAM,CAACK,WAAP,CAAmBC,GAAnB,CAAuB,KAAKT,WAA5B,EAhDiC,CAkDjC;;AACA,eAAKsB,MAAL,CAAYpB,EAAZ,EAAgBC,MAAhB;AACA,eAAKoB,QAAL,CAAcrB,EAAd,EAAkBC,MAAlB;AACH;;AAEDmB,QAAAA,MAAM,CAACpB,EAAD,EAAaC,MAAb,EAAqB;AACvB;AACA,gBAAMqB,QAAQ,GAAG9B,EAAE,EAAnB;AACAC,UAAAA,IAAI,CAAC8B,cAAL,CAAoBD,QAApB,EAA8BrB,MAAM,CAACK,WAArC,EAAkDL,MAAM,CAACuB,SAAP,GAAmBxB,EAArE,EAHuB,CAKvB;;AACA,gBAAMyB,UAAU,GAAGxB,MAAM,CAACyB,IAAP,CAAYC,gBAAZ,EAAnB;AACA1B,UAAAA,MAAM,CAACyB,IAAP,CAAYE,gBAAZ,CACIH,UAAU,CAACvB,CAAX,GAAeoB,QAAQ,CAACpB,CAD5B,EAEIuB,UAAU,CAACrB,CAFf,EAGIqB,UAAU,CAACI,CAAX,GAAeP,QAAQ,CAACO,CAH5B;AAKH;;AAEDR,QAAAA,QAAQ,CAACrB,EAAD,EAAaC,MAAb,EAAqB;AACzB;AACA,cAAIA,MAAM,CAACK,WAAP,CAAmBW,MAAnB,KAA8B,GAAlC,EAAuC,OAFd,CAIzB;;AACA,gBAAMa,UAAU,GAAG,IAAIvC,IAAJ,EAAnB;AACAA,UAAAA,IAAI,CAACwC,UAAL,CAAgBD,UAAhB,EAA4B7B,MAAM,CAACK,WAAnC,EAAgDb,IAAI,CAACuC,EAArD,EANyB,CAQzB;;AACA,gBAAMC,UAAU,GAAGhC,MAAM,CAACyB,IAAP,CAAYhB,gBAAZ,EAAnB;AACAnB,UAAAA,IAAI,CAAC2C,KAAL,CAAWD,UAAX,EAAuBA,UAAvB,EAAmCH,UAAnC,EAA+C9B,EAAE,GAAGC,MAAM,CAACkC,WAA3D,EAVyB,CAYzB;;AACAlC,UAAAA,MAAM,CAACyB,IAAP,CAAYU,gBAAZ,CAA6BH,UAA7B;AACH;;AA3FmC,O,mFAGnCrC,Q;;;;;iBAC0B,G","sourcesContent":["import { _decorator, Component, find, Node, Quat, v3, Vec3 } from 'cc';\r\nimport { VirtualInput } from '../UI/VirtuallInput';\r\nconst { ccclass, property } = _decorator;\r\n\r\n@ccclass('MoveBase')\r\nexport class MoveBase extends Component {\r\n\r\n    // 添加移动平滑系数\r\n    @property\r\n    moveSmoothFactor: number = 0.2; // 移动平滑系数，值越小越平滑\r\n\r\n    // 保存上一帧的移动方向，用于平滑处理\r\n    private lastMoveDir: Vec3 = v3();\r\n    handleInput(dt: number, entity: any) {\r\n\r\n        const x = VirtualInput.horizontal;\r\n        const y = VirtualInput.vertical;\r\n\r\n        // 如果没有输入，停止移动\r\n        if (x === 0 && y === 0) {\r\n            entity.destForward.set(0, 0, 0);\r\n            return;\r\n        }\r\n\r\n        const camNode = find(\"Main Camera\");\r\n        if (!camNode) return;\r\n\r\n        // 获取摄像机的世界旋转\r\n        const camRot = camNode.getWorldRotation();\r\n\r\n        // 计算基于摄像机的移动方向\r\n        const forward = new Vec3(0, 0, -1);\r\n        const right = new Vec3(1, 0, 0);\r\n\r\n        // 将方向向量应用摄像机旋转\r\n        Vec3.transformQuat(forward, forward, camRot);\r\n        Vec3.transformQuat(right, right, camRot);\r\n\r\n        // 只保留水平分量\r\n        forward.y = 0;\r\n        right.y = 0;\r\n        forward.normalize();\r\n        right.normalize();\r\n\r\n        // 计算最终移动方向\r\n        const moveDir = new Vec3();\r\n        Vec3.scaleAndAdd(moveDir, moveDir, right, x);\r\n        Vec3.scaleAndAdd(moveDir, moveDir, forward, y);\r\n        moveDir.normalize();\r\n\r\n        // 对移动方向进行平滑处理，避免突然变化\r\n        if (moveDir.length() > 0.1) {\r\n            moveDir.normalize();\r\n            // 线性插值平滑过渡\r\n            Vec3.lerp(this.lastMoveDir, this.lastMoveDir, moveDir, this.moveSmoothFactor);\r\n            this.lastMoveDir.normalize();\r\n        } else {\r\n            this.lastMoveDir.set(0, 0, 0);\r\n        }\r\n\r\n        // 保存目标方向\r\n        entity.destForward.set(this.lastMoveDir);\r\n\r\n        // 执行移动和旋转\r\n        this.doMove(dt, entity);\r\n        this.doRotate(dt, entity);\r\n    }\r\n\r\n    doMove(dt: number, entity) {\r\n        // 使用目标方向和速度计算位移\r\n        const velocity = v3();\r\n        Vec3.multiplyScalar(velocity, entity.destForward, entity.moveSpeed * dt);\r\n\r\n        // 更新位置\r\n        const currentPos = entity.node.getWorldPosition();\r\n        entity.node.setWorldPosition(\r\n            currentPos.x + velocity.x,\r\n            currentPos.y,\r\n            currentPos.z + velocity.z\r\n        );\r\n    }\r\n\r\n    doRotate(dt: number, entity) {\r\n        // 如果没有目标方向，不进行旋转\r\n        if (entity.destForward.length() < 0.1) return;\r\n\r\n        // 计算目标旋转\r\n        const targetQuat = new Quat();\r\n        Quat.fromViewUp(targetQuat, entity.destForward, Vec3.UP);\r\n\r\n        // 平滑旋转到目标方向\r\n        const currentRot = entity.node.getWorldRotation();\r\n        Quat.slerp(currentRot, currentRot, targetQuat, dt * entity.rotateSpeed);\r\n\r\n        // 应用旋转\r\n        entity.node.setWorldRotation(currentRot);\r\n    }\r\n}\r\n\r\n\r\n"]}