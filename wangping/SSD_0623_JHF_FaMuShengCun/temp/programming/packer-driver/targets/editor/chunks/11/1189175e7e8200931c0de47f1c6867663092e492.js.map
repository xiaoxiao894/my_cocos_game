{"version":3,"sources":["file:///D:/Cocos/PlayAble/SSD_0623_JHF_FaMuShengCun/assets/JavaScript/Placing/SceneCoinConManager.ts"],"names":["_decorator","Component","Quat","tween","Vec3","StackManager","DataManager","ccclass","property","SceneCoinConManager","_row","_col","_gapX","_gapY","_gapZ","_maxLayer","start","node","update","deltaTime","iconList","Instance","monsterManager","getDrops","length","stackManager","i","item","isValid","startPos","getWorldPosition","setParent","slot","assignSlot","curSlot","curIndex","indexOfSlot","startRot","rotation","clone","tmpQ","totalSpinDeg","tParam","t","to","onUpdate","oneMinusT","betterIndex","findLowestVacantBefore","moved","moveAssignment","s","getSlotByIndex","endPosNow","getSlotWorldPos","ctrlX","x","ctrlY","y","ctrlZ","z","pos","setWorldPosition","angle","fromEuler","curQ","multiply","setRotation","onComplete","meatScaleNode","getChildByName","setScale","eulerAngles","stopSelfRotate","localPos","inverseTransformPoint","setPosition","scale","easing"],"mappings":"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","sourcesContent":["import { _decorator, Component, find, Node, Quat, tween, Vec3 } from 'cc';\r\nimport { StackManager } from '../StackSlot/StackManager';\r\nimport { DataManager } from '../Global/DataManager';\r\nconst { ccclass, property } = _decorator;\r\n\r\n@ccclass('SceneCoinConManager')\r\nexport class SceneCoinConManager extends Component {\r\n\r\n    private _row = 2;\r\n    private _col = 3;\r\n    private _gapX = 1.2;\r\n    private _gapY = 1.5;\r\n    private _gapZ = 0.4;\r\n    private _maxLayer = 20000;\r\n\r\n    start() {\r\n        if (this.node && !this.node[`__stackManager`]) {\r\n            this.node[`__stackManager`] = new StackManager(this._row, this._col, this._gapX, this._gapY, this._gapZ, this._maxLayer);\r\n        }\r\n    }\r\n\r\n    update(deltaTime: number) {\r\n        const iconList = DataManager.Instance.monsterManager.getDrops();\r\n        if (!iconList || iconList.length <= 0) return;\r\n\r\n        const stackManager = this.node[\"__stackManager\"];\r\n        if (!stackManager) return;\r\n\r\n        for (let i = 0; i < iconList.length; i++) {\r\n            const item = iconList[i];\r\n            if (!item || !item.isValid) continue;\r\n\r\n            const startPos = item.getWorldPosition();\r\n            item.setParent(this.node); // 保留你的原始逻辑\r\n\r\n            // 仍然使用原来的 assignSlot（不引入预留/占用新语义）\r\n            const slot = stackManager.assignSlot(item);\r\n            if (!slot) continue;\r\n\r\n            // 当前占用的槽位与索引（飞行途中可能被“降档”到更前的空槽）\r\n            let curSlot = slot;\r\n            let curIndex = stackManager.indexOfSlot(curSlot);\r\n\r\n            const startRot = item.rotation.clone();\r\n            const tmpQ = new Quat();\r\n            const totalSpinDeg = 720;\r\n            const tParam = { t: 0 };\r\n\r\n            tween(tParam)\r\n                .to(1, { t: 1 }, {\r\n                    onUpdate: () => {\r\n                        const t = tParam.t;\r\n                        const oneMinusT = 1 - t;\r\n\r\n                        // 尝试“降档补洞”：若前方出现更靠前的空槽，更新占用关系\r\n                        const betterIndex = stackManager.findLowestVacantBefore(curIndex);\r\n                        if (betterIndex >= 0) {\r\n                            const moved = stackManager.moveAssignment(item, curIndex, betterIndex);\r\n                            if (moved) {\r\n                                curIndex = betterIndex;\r\n                                const s = stackManager.getSlotByIndex(curIndex);\r\n                                if (s) curSlot = s;\r\n                            }\r\n                        }\r\n\r\n                        //  每帧以“当前槽位”的世界坐标为终点（父节点/布局变化也能跟上）\r\n                        const endPosNow = stackManager.getSlotWorldPos(curSlot, this.node);\r\n\r\n                        // 每帧重算控制点\r\n                        const ctrlX = (startPos.x + endPosNow.x) * 0.5;\r\n                        const ctrlY = (startPos.y + endPosNow.y) * 0.5 + 20;\r\n                        const ctrlZ = (startPos.z + endPosNow.z) * 0.5;\r\n\r\n                        // 二次贝塞尔插值\r\n                        const pos = new Vec3(\r\n                            oneMinusT * oneMinusT * startPos.x + 2 * oneMinusT * t * ctrlX + t * t * endPosNow.x,\r\n                            oneMinusT * oneMinusT * startPos.y + 2 * oneMinusT * t * ctrlY + t * t * endPosNow.y,\r\n                            oneMinusT * oneMinusT * startPos.z + 2 * oneMinusT * t * ctrlZ + t * t * endPosNow.z\r\n                        );\r\n                        item.setWorldPosition(pos);\r\n\r\n                        // 自旋\r\n                        const angle = totalSpinDeg * t;\r\n                        Quat.fromEuler(tmpQ, angle, 0, 0);\r\n                        const curQ = new Quat();\r\n                        Quat.multiply(curQ, startRot, tmpQ);\r\n                        item.setRotation(curQ); // 局部旋转\r\n                    },\r\n                    onComplete: () => {\r\n                        // 落地时再次读取“当前槽位”的世界坐标，避免中途变化导致错位\r\n                        const endPosNow = stackManager.getSlotWorldPos(curSlot, this.node);\r\n\r\n                        const meatScaleNode = item.getChildByName(\"Meat\");\r\n                        if (meatScaleNode) meatScaleNode.setScale(3, 3, 3);\r\n\r\n                        // 终点对齐与入栈（保持你的原逻辑）\r\n                        item.setWorldPosition(endPosNow);\r\n                        item.setParent(this.node);\r\n                        item['__fallingTarget'] = true;\r\n                        item.eulerAngles = new Vec3(0, 0, 0);\r\n                        DataManager.Instance.monsterManager.stopSelfRotate(item);\r\n\r\n                        const localPos = new Vec3();\r\n                        this.node.inverseTransformPoint(localPos, endPosNow);\r\n                        item.setPosition(localPos);\r\n\r\n                        tween(item)\r\n                            .to(0.15, { scale: new Vec3(1.2, 1.2, 1.2) }, { easing: 'quadOut' })\r\n                            .to(0.05, { scale: new Vec3(1, 1, 1) }, { easing: 'quadOut' })\r\n                            .start();\r\n\r\n                        // // 如果需要复位为起始旋转，解注即可：\r\n                        // item.setRotation(startRot);\r\n                    }\r\n                })\r\n                .start();\r\n        }\r\n    }\r\n\r\n\r\n    // update(deltaTime: number) {\r\n    //     const iconList = DataManager.Instance.monsterManager.getDrops();\r\n    //     if (iconList && iconList.length <= 0) return;\r\n\r\n    //     const stackManager = this.node[\"__stackManager\"];\r\n    //     if (!stackManager) {\r\n    //         // console.warn(\"meatCon 没有 stackManager\");\r\n    //         return;\r\n    //     }\r\n\r\n    //     for (let i = 0; i < iconList.length; i++) {\r\n    //         const item = iconList[i];\r\n    //         if (!item || !item.isValid) continue;\r\n\r\n    //         const startPos = item.getWorldPosition();\r\n    //         item.setParent(this.node);\r\n\r\n    //         const slot = stackManager.assignSlot(item);\r\n    //         if (!slot) {\r\n    //             // console.warn(\"没有可用槽位\");\r\n    //             continue;\r\n    //         }\r\n\r\n    //         const endPos = stackManager.getSlotWorldPos(slot, this.node);\r\n    //         const controlPoint = startPos.clone().lerp(endPos, 0.5).add3f(0, 15, 0);\r\n\r\n    //         const tParam = { t: 0 };\r\n\r\n    //         tween(tParam)\r\n    //             .to(0.3, { t: 1 }, {\r\n    //                 onUpdate: () => {\r\n    //                     const t = tParam.t;\r\n    //                     const oneMinusT = 1 - t;\r\n\r\n    //                     const pos = new Vec3(\r\n    //                         oneMinusT * oneMinusT * startPos.x + 2 * oneMinusT * t * controlPoint.x + t * t * endPos.x,\r\n    //                         oneMinusT * oneMinusT * startPos.y + 2 * oneMinusT * t * controlPoint.y + t * t * endPos.y,\r\n    //                         oneMinusT * oneMinusT * startPos.z + 2 * oneMinusT * t * controlPoint.z + t * t * endPos.z\r\n    //                     );\r\n\r\n    //                     item.setWorldPosition(pos);\r\n    //                 },\r\n    //                 onComplete: () => {\r\n    //                     const meatScaleNode = item.getChildByName(\"Meat\");\r\n    //                     if (meatScaleNode) {\r\n    //                         meatScaleNode.setScale(3, 3, 3);\r\n    //                     }\r\n\r\n    //                     item.setWorldPosition(endPos);\r\n    //                     item.setParent(this.node);\r\n    //                     item[`__fallingTarget`] = true;\r\n\r\n    //                     const localPos = new Vec3();\r\n    //                     this.node.inverseTransformPoint(localPos, endPos);\r\n    //                     item.setPosition(localPos);\r\n    //                 }\r\n    //             })\r\n    //             .start();\r\n    //     }\r\n\r\n    // }\r\n}\r\n\r\n\r\n"]}