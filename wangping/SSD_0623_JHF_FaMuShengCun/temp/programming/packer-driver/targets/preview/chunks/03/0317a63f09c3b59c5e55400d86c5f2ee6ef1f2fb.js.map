{"version":3,"sources":["file:///D:/Cocos/PlayAble/SSD_0623_JHF_FaMuShengCun/assets/JavaScript/StackSlot/StackManager.ts"],"names":["StackManager","Vec3","Mat4","StackSlot","constructor","row","col","gapX","gapZ","gapY","maxLayer","slots","layer","r","c","pos","push","assignSlot","node","slot","find","s","isOccupied","assignedNode","releaseSlot","release","getLastOccupiedSlot","lastOccupiedSlot","i","length","getSlotWorldPos","parent","out","m","getWorldMatrix","transformMat4","position","getAllOccupiedSlots","filter","getSlotByIndex","index","indexOfSlot","indexOf","findLowestVacantBefore","moveAssignment","item","fromIndex","toIndex","from","to"],"mappings":"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","sourcesContent":["// StackManager.ts\r\nimport { Vec3, Node as CocosNode, Mat4 } from 'cc';\r\nimport { StackSlot } from './StackSlot';\r\n\r\nexport class StackManager {\r\n    private slots: StackSlot[] = [];\r\n\r\n    constructor(row: number, col: number, gapX: number, gapZ: number, gapY: number = 0.5, maxLayer: number = 100) {\r\n        for (let layer = 0; layer < maxLayer; layer++) {\r\n            for (let r = 0; r < row; r++) {\r\n                for (let c = 0; c < col; c++) {\r\n                    const pos = new Vec3(c * gapX, layer * gapY, r * gapZ);\r\n                    this.slots.push(new StackSlot(pos));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // ====== 你的原始逻辑：不改 ======\r\n    assignSlot(node: CocosNode): StackSlot | null {\r\n        const slot = this.slots.find(s => !s.isOccupied);\r\n        if (!slot) return null;\r\n        slot.assignedNode = node;\r\n        return slot;\r\n    }\r\n\r\n    releaseSlot(node: CocosNode) {\r\n        for (const slot of this.slots) {\r\n            if (slot.assignedNode === node) {\r\n                slot.release();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    getLastOccupiedSlot(): StackSlot | null {\r\n        let lastOccupiedSlot: StackSlot | null = null;\r\n        for (let i = 0; i < this.slots.length; i++) {\r\n            if (this.slots[i].isOccupied) lastOccupiedSlot = this.slots[i];\r\n            else return lastOccupiedSlot;\r\n        }\r\n        return lastOccupiedSlot;\r\n    }\r\n\r\n    /**  更稳的世界坐标获取：包含位移/旋转/缩放/层级 */\r\n    getSlotWorldPos(slot: StackSlot, parent: CocosNode): Vec3 {\r\n        const out = new Vec3();\r\n        const m = new Mat4();\r\n        parent.getWorldMatrix(m);\r\n        Vec3.transformMat4(out, slot.position, m); // 本地 -> 世界\r\n        return out;\r\n    }\r\n\r\n    public getAllOccupiedSlots(): StackSlot[] {\r\n        return this.slots.filter(s => s.assignedNode);\r\n    }\r\n\r\n\r\n    /** 按索引取槽位 */\r\n    public getSlotByIndex(index: number): StackSlot | null {\r\n        return (index >= 0 && index < this.slots.length) ? this.slots[index] : null;\r\n    }\r\n\r\n    /** 槽位转索引 */\r\n    public indexOfSlot(slot: StackSlot): number {\r\n        return this.slots.indexOf(slot);\r\n    }\r\n\r\n    /** 在 index 之前寻找最靠前的空洞位（返回索引；找不到返回 -1） */\r\n    public findLowestVacantBefore(index: number): number {\r\n        for (let i = 0; i < index; i++) {\r\n            const s = this.slots[i];\r\n            if (!s.isOccupied) return i;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * 将 item 的占用从 fromIndex 移到 toIndex\r\n     * 仅更新占用关系，不改变外部飞行动画逻辑\r\n     */\r\n    public moveAssignment(item: CocosNode, fromIndex: number, toIndex: number): boolean {\r\n        const from = this.getSlotByIndex(fromIndex);\r\n        const to   = this.getSlotByIndex(toIndex);\r\n        if (!from || !to) return false;\r\n        if (from.assignedNode !== item) return false;\r\n        if (to.isOccupied) return false;\r\n        from.assignedNode = null;\r\n        to.assignedNode = item;\r\n        return true;\r\n    }\r\n}\r\n"]}