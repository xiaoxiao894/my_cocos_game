{"version":3,"sources":["file:///D:/Cocos/PlayAble/L_DefendTheCup/assets/JavaScript/Monster/FlowField.ts"],"names":["FlowCell","FlowField","Collider","Vec2","Vec3","Singleton","DataManager","cost","direction","_gridSize","_gridWidth","_gridHeight","_grid","_obstacles","Instance","GetInstance","init","obstacles","Array","x","y","registerObstacles","updateFlowField","player","node","getWorldPosition","clone","width","height","collider","getComponent","radius","size","z","addObstacle","worldPosition","worldPos","gridPos","worldToGrid","isValidGrid","push","addLargeObstacle","centerPos","dx","dy","add","playerWorldPos","length","playerGridPos","Infinity","queue","current","shift","currentCost","neighbors","neighbor","moveCost","isObstacle","newCost","dir","normalize","Math","floor","some","obs","obsGridPos","equals","Number","isInteger","gridToWorld","yHeight","getDirection","ZERO"],"mappings":"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","sourcesContent":["import { _decorator, BoxCollider, Collider, Color, Component, debug, director, geometry, Node, SphereCollider, Vec2, Vec3 } from 'cc';\r\nimport Singleton from '../Base/Singleton';\r\nimport { DataManager } from '../Global/DataManager';\r\n\r\nclass FlowCell {\r\n    cost: number = 0;       // 到达玩家的代价\r\n    direction: Vec2 = new Vec2(0, 0); // 移动方向\r\n}\r\n/**\r\n * 流场避障算法\r\n */\r\nexport class FlowField extends Singleton {\r\n    private _gridSize = 1; // 每个格子的大小（世界单位）\r\n\r\n    private _gridWidth = 50; // 网格宽度（格子数）\r\n\r\n    private _gridHeight = 50; // 网格高度（格子数）\r\n\r\n    private _grid: FlowCell[][] = [];\r\n    private _obstacles: Vec3[] = []; // 静态障碍物位置\r\n\r\n    static get Instance() {\r\n        return super.GetInstance<FlowField>();\r\n    }\r\n\r\n    public init(obstacles: Node[]) {\r\n        // 初始化网格\r\n        this._grid = new Array(this._gridWidth);\r\n        for (let x = 0; x < this._gridWidth; x++) {\r\n            this._grid[x] = new Array(this._gridHeight);\r\n            for (let y = 0; y < this._gridHeight; y++) {\r\n                this._grid[x][y] = new FlowCell();\r\n            }\r\n        }\r\n        // 初始化障碍物（新增代码）\r\n        this._obstacles = [];\r\n        this.registerObstacles(obstacles);\r\n        this.updateFlowField(DataManager.Instance.player?.node?.getWorldPosition()?.clone());\r\n    }\r\n\r\n    /**\r\n     * 注册所有静态障碍物\r\n     */\r\n    private registerObstacles(obstacles: Node[]) {\r\n        //方式1：通过节点\r\n        for (const node of obstacles) {\r\n            let width: number = 1;\r\n            let height: number = 1;\r\n            let collider: Collider = node.getComponent(Collider);\r\n            if (collider) {\r\n                if ('radius' in collider) {\r\n                    // 类型推断为 SphereCollider\r\n                    width = (collider as any).radius * 2;\r\n                    height = width;\r\n                } else if ('size' in collider) {\r\n                    // 类型推断为 BoxCollider\r\n                    const size = (collider as any).size;\r\n                    width = size.x;\r\n                    height = size.z;\r\n                }\r\n                //this.addLargeObstacle(node.worldPosition,width,height);\r\n                this.addObstacle(node.worldPosition);\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 添加单个障碍物\r\n     * @param worldPos 世界坐标\r\n     */\r\n    public addObstacle(worldPos: Vec3) {\r\n        const gridPos = this.worldToGrid(worldPos);\r\n        if (this.isValidGrid(gridPos)) {\r\n            this._obstacles.push(worldPos.clone());\r\n            // console.log(`障碍物添加在网格: [${gridPos.x},${gridPos.y}]`);\r\n        }\r\n    }\r\n\r\n    public addLargeObstacle(centerPos: Vec3, width: number, height: number) {\r\n        // console.log(`大障碍物: [${width},${height}]`);\r\n        for (let dx = -width / 2; dx <= width / 2; dx++) {\r\n            for (let dy = -height / 2; dy <= height / 2; dy++) {\r\n                this.addObstacle(centerPos.add(new Vec3(dx, 0, dy)));\r\n            }\r\n        }\r\n    }\r\n\r\n    // 更新流场（玩家位置变化时调用）\r\n    public updateFlowField(playerWorldPos: Vec3) {\r\n        if (!playerWorldPos || this._grid.length <= 0) {\r\n            return;\r\n        }\r\n        // 1. 转换玩家位置到网格坐标\r\n        const playerGridPos = this.worldToGrid(playerWorldPos);\r\n\r\n        // 2. 重置所有格子代价\r\n        for (let x = 0; x < this._gridWidth; x++) {\r\n            for (let y = 0; y < this._gridHeight; y++) {\r\n                if (this._grid.length > 0) {\r\n                    this._grid[x][y].cost = Infinity;\r\n                }\r\n            }\r\n        }\r\n\r\n        // 3. 从玩家位置开始广度优先搜索（BFS）\r\n        const queue: Vec2[] = [playerGridPos];\r\n        this._grid[playerGridPos.x][playerGridPos.y].cost = 0;\r\n\r\n        while (queue.length > 0) {\r\n            const current = queue.shift()!;\r\n            const currentCost = this._grid[current.x][current.y].cost;\r\n\r\n            // 检查4个相邻格子（上、下、左、右）\r\n            const neighbors = [\r\n                new Vec2(current.x, current.y + 1),\r\n                new Vec2(current.x, current.y - 1),\r\n                new Vec2(current.x + 1, current.y),\r\n                new Vec2(current.x - 1, current.y)\r\n            ];\r\n\r\n            for (const neighbor of neighbors) {\r\n                if (this.isValidGrid(neighbor)) {\r\n                    // 计算新代价 = 当前代价 + 移动成本（障碍物则成本极高）\r\n                    const moveCost = this.isObstacle(neighbor) ? 1000 : 1;\r\n                    const newCost = currentCost + moveCost;\r\n\r\n                    if (newCost < this._grid[neighbor.x][neighbor.y].cost) {\r\n                        this._grid[neighbor.x][neighbor.y].cost = newCost;\r\n                        queue.push(neighbor);\r\n\r\n                        // 记录移动方向（指向更低代价的邻居）\r\n                        const dir = new Vec2(\r\n                            current.x - neighbor.x,\r\n                            current.y - neighbor.y\r\n                        ).normalize();\r\n                        this._grid[neighbor.x][neighbor.y].direction = dir;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // 辅助方法：世界坐标转网格坐标\r\n    public worldToGrid(worldPos: Vec3): Vec2 {\r\n        return new Vec2(\r\n            Math.floor(worldPos.x / this._gridSize + this._gridWidth / 2),\r\n            Math.floor(worldPos.z / this._gridSize + this._gridHeight / 2) // 3D游戏用z轴\r\n        );\r\n    }\r\n\r\n    // 检查是否为障碍物\r\n    private isObstacle(gridPos: Vec2): boolean {\r\n        return this._obstacles.some(obs => {\r\n            const obsGridPos = this.worldToGrid(obs);\r\n            return obsGridPos.equals(gridPos);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * 检查网格坐标是否在有效范围内\r\n     */\r\n    private isValidGrid(gridPos: Vec2): boolean {\r\n        // 使用Number.isInteger更严格地检查整数索引\r\n        return (\r\n            Number.isInteger(gridPos.x) &&\r\n            Number.isInteger(gridPos.y) &&\r\n            gridPos.x >= 0 &&\r\n            gridPos.x < this._gridWidth &&\r\n            gridPos.y >= 0 &&\r\n            gridPos.y < this._gridHeight\r\n        );\r\n    }\r\n\r\n    /**\r\n     * 将网格坐标转换为世界坐标\r\n     * @param gridPos 网格坐标 (x,y 表示网格行列索引)\r\n     * @param yHeight 世界Y轴高度（默认0）\r\n     */\r\n    private gridToWorld(gridPos: Vec2, yHeight: number = 0): Vec3 {\r\n        // 计算世界坐标（假设网格原点在场景中心）\r\n        return new Vec3(\r\n            (gridPos.x - this._gridWidth / 2) * this._gridSize,\r\n            yHeight, // Y轴高度\r\n            (gridPos.y - this._gridHeight / 2) * this._gridSize // 3D用Z轴\r\n        );\r\n    }\r\n\r\n    /**\r\n     * 获取指定网格的移动方向\r\n     * @param gridPos 网格坐标\r\n     * @returns 归一化的方向向量 (Vec2)\r\n     */\r\n    public getDirection(gridPos: Vec2): Vec2 {\r\n        if (!this.isValidGrid(gridPos)) {\r\n            return Vec2.ZERO;\r\n        }\r\n        // 返回预计算的方向（流场生成时已归一化）\r\n        return this._grid[gridPos.x][gridPos.y].direction.clone();\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n"]}